-- =============================================
-- Author:		Brad Chen
-- https://github.com/bradchendev/Power-SQL-Scripts
-- https://blogs.msdn.microsoft.com/bradchen/
-- Create date: 2017/7/8
-- Description:	Tempdb
-- tempdb Database
-- https://docs.microsoft.com/en-us/sql/relational-databases/databases/tempdb-database
-- Troubleshooting Insufficient Disk Space in tempdb
-- https://technet.microsoft.com/en-us/library/ms176029(v=sql.105).aspx
-- Optimizing tempdb Performance
-- https://technet.microsoft.com/en-us/library/ms175527(v=sql.105).aspx
-- Working with tempdb in SQL Server 2005
-- https://technet.microsoft.com/zh-tw/library/cc966545.aspx
-- Compilation of SQL Server TempDB IO Best Practices
-- https://blogs.msdn.microsoft.com/cindygross/2009/11/20/compilation-of-sql-server-tempdb-io-best-practices/
-- TempDB Monitoring and Troubleshooting: Out of Space
-- https://blogs.msdn.microsoft.com/sqlserverstorageengine/2009/01/11/tempdb-monitoring-and-troubleshooting-out-of-space/
-- Monitoring tempdb Transactions and Space usage
-- https://blogs.msdn.microsoft.com/deepakbi/2010/04/13/monitoring-tempdb-transactions-and-space-usage/
-- =============================================



--Internal objects
	--Internal objects are created internally by SQL Server. Applications cannot directly insert into or delete rows from internal objects. Internal object metadata is stored in memory. The metadata does not appear in system catalog views such as sys.all_objects. Internal objects are considered to be hidden objects.
	--Internal objects are used:
	--•	Sort: To store intermediate runs for sort. (including distinct sort)
	--•	Hash match: To store intermediate results for hash joins and hash aggregates.
			--Look at the number of rows and row size returned by the first input operator.
	--•	Spool: By queries that need a spool(including table spool, nonclustered index spool) to store intermediate results. (Ex. DBCC CHECK)
			-- This operator requires that the full input rowset be stored in tempdb.
	--•	To store XML variables or other large object (LOB) data type variables. The LOB data type includes all of the large object types: text, image, ntext, varchar(max), varbinary(max), and all others. 
	--•	By keyset cursors to store the keys.
	--•	By static cursors to store a query result.
	--•	By Service Broker to store messages in transit. (Query notification)
	--•	By INSTEAD OF triggers to store data for internal processing.
	
	-- Internal objects不會產生交易紀錄
	-- Updates to internal objects do not generate log records. Page allocations on internal objects do not generate log records unless on a sort unit. If the statement fails, these objects are deallocated. Each internal object occupies at least nine pages (one IAM page and eight data pages) in tempdb.

--Version store
	--有2類
	--•	Online index build
	--•	Common version store https://msdn.microsoft.com/en-us/library/ms175492.aspx
	--     (1)snapshot isolation
	--     (2)AFTER triggers (INSTEAD OF triggers do not generate versions.)
	--     (3)MARS (multiple active result sets), (versions are generated by the UPDATE or DELETE statement when there is a pending SELECT on the same transaction and the same connection)
	--
	-- do not appear in catalog views, such as sys.all_objects.
	-- Inserts into the version store do not generate log records. Each unit can store many row versions. (不會產生交易紀錄)

--User objects
	--•	global temporary tables such as ##t
	--•	local temporary tables such as #t (include table variables such as @t)
	--•	the return value in table valued functions
	--•	the mapping index for online clustered index build with the SORT_IN_TEMPDB option.

	-- User objects appear in catalog views such as sys.all_objects. Sp_spaceused can show the size occupied by these objects. User objects include both user-defined tables and indexes, and system catalog tables and indexes.
	-- 對User objects進行操作會產生交易紀錄
	-- Operations on user objects in tempdb are mostly logged. Bulk copy program (BCP), bulk insert, SELECT INTO, and index rebuild operations are bulk logged. This is exactly the same as in other databases with the recovery model set to simple.













--DBCC SHRINKFILE (Transact-SQL)
--https://msdn.microsoft.com/en-us/library/ms189493.aspx

USE UserDB;  
GO  
DBCC SHRINKFILE (DataFile1, 7);  
GO  

GO  
-- Create a data file and assume it contains data.  
ALTER DATABASE AdventureWorks2012   
ADD FILE (  
    NAME = Test1data,  
    FILENAME = 'C:\t1data.ndf',  
    SIZE = 5MB  
    );  
GO  
-- Empty the data file.  
DBCC SHRINKFILE (Test1data, EMPTYFILE);  
GO  
-- Remove the data file from the database.  
ALTER DATABASE AdventureWorks2012  
REMOVE FILE Test1data;  
GO  


--The file "C:\Program Files\Microsoft SQL Server\MSSQL10_50.MSSQLSERVER\MSSQL\DATA\tempdev4.ndf" has been modified in the system catalog. The new path will be used the next time the database is started.
--Msg 5042, Level 16, State 1, Line 1
--The file 'tempdev4' cannot be removed because it is not empty.

-- 出現5042錯誤tempdev4還是存在
select * from sys.database_files

-- tempdev4 不存在
select * from sys.master_files
where database_id = 2

-- tempdev4 不存在
select * from sys.sysaltfiles
where dbid = 2


-- sql restart之後，tempdev4才會消失





select * from sys.dm_os_performance_counters
where 
(
object_name = 'SQLServer:Access Methods'
and counter_name in ('Workfiles Created/sec','Worktables Created/sec', 'Worktables From Cache Ratio')
)
or
(
object_name = 'SQLServer:General Statistics'
and counter_name in ('Temp Tables Creation Rate', 'Temp Tables For Destruction')
);



SELECT * 
FROM sys.sysprocesses  
WHERE lastwaittype like 'PAGE%LATCH_%' AND waitresource like '2:%'


--INF: Understanding and resolving SQL Server blocking problems
--https://support.microsoft.com/en-us/kb/224453
--Waitresource:
--Table	DatabaseID:ObjectID:IndexID	TAB: 5:261575970:1
--age	DatabaseID:FileID:PageID	PAGE: 5:1:104
--Key	DatabaseID:Hobt_id (Hash value for index key)	KEY: 5:72057594044284928 (3300a4f361aa)
--Row	DatabaseID:FileID:PageID:Slot(row)	RID: 5:1:104:3
--Compile	DatabaseID:ObjectID [[COMPILE]]	TAB: 5:834102012 [[COMPILE]]


SELECT session_id, wait_duration_ms, wait_type, resource_description
FROM sys.dm_os_waiting_tasks
WHERE wait_type like 'PAGE%LATCH_%' AND resource_description like '2:%'




--You can look for PFS and SGAM pages by using waitresource.
--For example  ‘2:1:1’ or ‘2:1:3’ refer to the first PFS page and the first SGAM page in file1 of the tempdb database (id=2). SGAM pages re-occur after every 511,232 pages and each PFS page occurs after every 8,088 pages

--GAM pages record what extents have been allocated
--SGAM pages record which extents are currently being used as mixed extents and also have at least one unused page.
--Page Free Space (PFS) pages record the allocation status of each page, whether an individual page has been allocated, and the amount of free space on each page.「分頁可用空間 (PFS)」分頁會記錄每個分頁的配置狀態、個別分頁是否已配置，以及每個分頁的可用空間量。

--Recommendations to reduce allocation contention in SQL Server tempdb database
--https://support.microsoft.com/en-us/kb/2154845




SELECT P.object_id, object_name(P.object_id) as object_name, 
       P.index_id, BD.page_type
FROM 	 sys.dm_os_buffer_descriptors BD, sys.allocation_units A,
     	 sys.partitions P 
WHERE  BD.allocation_unit_id = A.allocation_unit_id and  
       A.container_id = P.partition_id


USE [tempdb];
SELECT
s.name AS [Name],
s.physical_name AS [FileName],
s.size * CONVERT(float,8) AS [Size_KB],
CAST(CASE s.type WHEN 2 THEN 0 ELSE CAST(FILEPROPERTY(s.name, 'SpaceUsed') AS float)* CONVERT(float,8) END AS float) AS [UsedSpace_KB],
s.file_id AS [ID], g.name
FROM
sys.filegroups AS g
INNER JOIN sys.master_files AS s ON ((s.type = 2 or s.type = 0) and s.database_id = db_id() and (s.drop_lsn IS NULL)) AND (s.data_space_id=g.data_space_id)
--WHERE 
--CAST(cast(g.name as varbinary(256)) AS sysname)='PRIMARY'
ORDER BY [ID] ASC





SELECT
                    sys.dm_exec_sessions.session_id AS [SESSION ID],
                    DB_NAME(database_id) AS [DB Name],
                    HOST_NAME AS [Host Name],
                    --program_name AS [Program Name],
                    --login_name AS [USER Name],
                    status,
                    --cpu_time AS [CPU TIME (in milisec)],
                    --total_scheduled_time AS [Total Scheduled TIME (in milisec)],
                    --total_elapsed_time AS    [Elapsed TIME (in milisec)],
                    --(memory_usage * 8)      AS [Memory USAGE (in KB)],
                    (user_objects_alloc_page_count * 8) AS [USER Objects Allocated_KB],
                    (user_objects_dealloc_page_count * 8) AS [USER Objects Deallocated_KB],
                    (internal_objects_alloc_page_count * 8) AS [Internal Objects Allocated_KB],
                    (internal_objects_dealloc_page_count * 8) AS [Internal Objects Deallocated_KB],
                    CASE is_user_process
                                         WHEN 1      THEN 'user session'
                                         WHEN 0      THEN 'system session'
                    END AS [SESSION Type], 
                    row_count AS [ROW COUNT]
	FROM sys.dm_db_session_space_usage
    inner join sys.dm_exec_sessions
    ON sys.dm_db_session_space_usage.session_id = sys.dm_exec_sessions.session_id
    WHERE 
		(user_objects_alloc_page_count <> 0 
		or user_objects_dealloc_page_count <> 0 
		or internal_objects_alloc_page_count <> 0 
		or internal_objects_dealloc_page_count <> 0 )
		and 
		(
		(user_objects_alloc_page_count <> user_objects_dealloc_page_count)
		or
		(internal_objects_alloc_page_count <> internal_objects_dealloc_page_count)
		)
	ORDER BY 5 desc,7 desc,6 desc,8 desc
	
		

use tempdb;
select * from  sys.dm_db_session_space_usage
    WHERE 
		user_objects_alloc_page_count <> 0 
		or user_objects_dealloc_page_count <> 0 
		or internal_objects_alloc_page_count <> 0 
		or internal_objects_dealloc_page_count <> 0 
GO		
		
		
select * from sys.dm_db_file_space_usage
-- file_id


use tempdb;
SELECT
SUM (user_object_reserved_page_count)*8 as [User Object KB], 
SUM (internal_object_reserved_page_count)*8 as [Internal Object KB],
SUM (version_store_reserved_page_count)*8  as [Version Store KB],
SUM (unallocated_extent_page_count)*8 as freespace_kb,
SUM (mixed_extent_page_count)*8 as mixedextent_kb
FROM sys.dm_db_file_space_usage
GO


 
-- running query use tempdb
;WITH task_space_usage AS (
    -- SUM alloc/delloc pages
    SELECT session_id,
           request_id,
           SUM(user_objects_alloc_page_count) AS User_objects_alloc_pages,
           SUM(user_objects_dealloc_page_count) AS User_objects_dealloc_pages,
           SUM(internal_objects_alloc_page_count) AS Internal_objects_alloc_pages,
           SUM(internal_objects_dealloc_page_count) AS Internal_objects_dealloc_pages
    FROM sys.dm_db_task_space_usage WITH (NOLOCK)
    WHERE session_id <> @@SPID
    GROUP BY session_id, request_id
)
SELECT TSU.session_id,
       TSU.User_objects_alloc_pages * 1.0 / 128 AS [User object MB],
       TSU.User_objects_dealloc_pages * 1.0 / 128 AS [User object dealloc MB],
       TSU.Internal_objects_alloc_pages * 1.0 / 128 AS [internal object MB],
       TSU.Internal_objects_dealloc_pages * 1.0 / 128 AS [internal object dealloc MB],
       EST.text,
       -- Extract statement from sql text
       ISNULL(
           NULLIF(
               SUBSTRING(
                 EST.text, 
                 ERQ.statement_start_offset / 2, 
                 CASE WHEN ERQ.statement_end_offset < ERQ.statement_start_offset 
                  THEN 0 
                 ELSE( ERQ.statement_end_offset - ERQ.statement_start_offset ) / 2 END
               ), ''
           ), EST.text
       ) AS [statement text],
       EQP.query_plan
FROM task_space_usage AS TSU
INNER JOIN sys.dm_exec_requests ERQ WITH (NOLOCK)
    ON  TSU.session_id = ERQ.session_id
    AND TSU.request_id = ERQ.request_id
OUTER APPLY sys.dm_exec_sql_text(ERQ.sql_handle) AS EST
OUTER APPLY sys.dm_exec_query_plan(ERQ.plan_handle) AS EQP
WHERE EST.text IS NOT NULL OR EQP.query_plan IS NOT NULL
ORDER BY 3 DESC; 



SELECT 
tdt.database_id,
Case database_transaction_state When  1 then '交易未初始化'
When  3 then '交易已初始化，但未產生任何記錄'
When  4 then '交易已產生記錄'
When 5 then '已準備交易'
When  10 then '已認可交易'
When  11 then '已回復交易'
When  12 then '正在認可交易' end as [DB_Tran_State],
	
	tdt.database_transaction_log_bytes_reserved,tst.session_id,
    t.[text], [statement] = COALESCE(NULLIF(
         SUBSTRING(
           t.[text],
           r.statement_start_offset / 2,
           CASE WHEN r.statement_end_offset < r.statement_start_offset
             THEN 0
             ELSE( r.statement_end_offset - r.statement_start_offset ) / 2 END
         ), ''
       ), t.[text])
     FROM sys.dm_tran_database_transactions AS tdt
     INNER JOIN sys.dm_tran_session_transactions AS tst
     ON tdt.transaction_id = tst.transaction_id
         LEFT OUTER JOIN sys.dm_exec_requests AS r
         ON tst.session_id = r.session_id
         OUTER APPLY sys.dm_exec_sql_text(r.plan_handle) AS t
     WHERE tdt.database_id = 2;



select 
	name,
	snapshot_isolation_state_desc, 
	is_read_committed_snapshot_on,
	recovery_model_desc,
	log_reuse_wait_desc,
	is_cdc_enabled
from sys.databases;
